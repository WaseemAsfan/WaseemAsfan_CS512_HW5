<!--All of the objects in the scene have a texture and a bumpmap.
However the olny object in the scene where the bumpmap in not just a
white image is the wall and the donut. The smoke is an animated texture on a plane geometry.
I drew many of the texture myself including the donut texture (most are just 
noisy colors but the donut texture is nice in my opinion).-->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW5</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }
  </style>
</head>

<body>
  <h2>Donut And Coffee</h2>
  <p>Edit vertex and fragment shaders on the left to get the result instantly.<br>
  Use mouse to drag and rotate the cube. <br>
  Use arrow keys and w, s keys to move the camera.<br>
  </p>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
      <canvas id="glcanvas" width="800" height="800"></canvas>
    </div>
  </div>

  <!-- Vertex shader -->
<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;
in vec3 aNormal;
in vec2 aTexCoord;

uniform float uTime;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;

out vec3 vColor;
out vec2 vTexCoord;
out vec3 vNormal;
out vec3 vPosition;

void main() {
  vec4 viewPosition = uModelViewMatrix * uModelTransformationMatrix * vec4(aPosition, 1.0);
  vPosition = viewPosition.xyz;
  
  gl_Position = uProjectionMatrix * viewPosition;
  vColor = aColor;
  vTexCoord = aTexCoord;
  
  mat3 uNormalMatrix = transpose(inverse(mat3(uModelViewMatrix * uModelTransformationMatrix)));
  vNormal = normalize(uNormalMatrix * aNormal);
}
</script>

<!-- Fragment Shader -->
<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 vColor;
in vec2 vTexCoord;
in vec3 vNormal;
in vec3 vPosition;

out vec4 fragColor;

uniform sampler2D uTex;
uniform sampler2D uBumpTex;

// Material properties
uniform float uKa;
uniform float uKd;
uniform float uKs;
uniform float uAlpha;
uniform float uBumpStrength;

// Lighting properties
uniform vec3 uLightAPos;
uniform vec3 uLightBPos;
uniform vec3 uViewPos;

vec3 calculateLight(vec3 lightPos, vec3 normal, vec3 viewDir) {
  // Diffuse
  vec3 lightDir = normalize(lightPos - vPosition);
  float cosTheta = max(dot(normal, lightDir), 0.0);
  vec3 diffuse = uKd * cosTheta * vec3(1.0);
  
  // Specular
  vec3 reflectDir = -reflect(lightDir, normal);
  float spec = pow(max(dot(viewDir, reflectDir), 0.0), uAlpha);
  vec3 specular = uKs * spec * vec3(1.0);
  
  return diffuse + specular;
}

void main() {
  vec4 texColor = texture(uTex, vTexCoord);
  float h = texture(uBumpTex, vTexCoord).r;
  float hu = texture(uBumpTex, vTexCoord + vec2(0.01, 0.0)).r;
  float hv = texture(uBumpTex, vTexCoord + vec2(0.0, 0.01)).r;
  
  // Calculate gradient
  vec3 gradient = vec3(
    (hu - h) * uBumpStrength,
    (hv - h) * uBumpStrength,
    1.0
  );
  
  // Perturb the normal
  vec3 normal = normalize(vNormal + gradient);
  
  vec3 ambient = uKa * vec3(1.0);
  
  vec3 viewDir = normalize(uViewPos - vPosition);
  
  vec3 lightContribution = calculateLight(uLightAPos, normal, viewDir);
  lightContribution += calculateLight(uLightBPos, normal, viewDir);
  
  // Combine all color
  vec3 finalColor = (ambient + lightContribution) * texColor.rgb;
  fragColor = vec4(finalColor, texColor.a);
}
</script>

  <script src="primitives.js"></script>
  <script src="transformations.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    // WebGL setup
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");

    let vertEditor = document.getElementById("vertEditor");
    let fragEditor = document.getElementById("fragEditor");
    vertEditor.value = document.getElementById("vertex-shader").textContent;
    fragEditor.value = document.getElementById("fragment-shader").textContent;

    let program, posLoc, colorLoc, uMVM, uPM, uMTM, timeLoc;
    let vbo, nbo, ibo, tbo;
    let uTexLoc, texCoordLoc, normalLoc;
    // Buffers
    function initBuffers(shape) {
      let texbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.texCoords, gl.STATIC_DRAW);

      let posbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.positions, gl.STATIC_DRAW);

      let colbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.colors, gl.STATIC_DRAW);

      let indbuff = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indbuff); 
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);

      let normbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.normals, gl.STATIC_DRAW);
      return {
        texbuff : texbuff,
        posbuff : posbuff,
        colbuff : colbuff,
        indbuff : indbuff,
        normbuff : normbuff
      };
    }
    function initTexture(url){
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);

      // Set a 1x1 white pixel as placeholder while image loads
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                    new Uint8Array([255, 255, 255, 255]));

      const image = new Image();
      image.src = url
      image.onload = function() {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      }
      return texture;
    }

    let uKaLoc, uKdLoc, uKsLoc, uAlphaLoc;
    let uLightAPosLoc, uViewPosLoc, uLightBPosLoc;
    let uBumpTexLoc, uBumpStrengthLoc;

    function initShaderProgram() {
      try {
        program = createProgram(gl, vertEditor.value, fragEditor.value);
        gl.useProgram(program);
        uTexLoc = gl.getUniformLocation(program, "uTex");
        texCoordLoc = gl.getAttribLocation(program, "aTexCoord");
        normalLoc = gl.getAttribLocation(program, "aNormal");

        uBumpTexLoc = gl.getUniformLocation(program, "uBumpTex");
        uBumpStrengthLoc = gl.getUniformLocation(program, "uBumpStrength");

        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");
        
        uKaLoc = gl.getUniformLocation(program, "uKa");
        uKdLoc = gl.getUniformLocation(program, "uKd");
        uKsLoc = gl.getUniformLocation(program, "uKs");
        uAlphaLoc = gl.getUniformLocation(program, "uAlpha");
        uLightAPosLoc = gl.getUniformLocation(program, "uLightAPos");
        uLightBPosLoc = gl.getUniformLocation(program, "uLightBPos");
        uViewPosLoc = gl.getUniformLocation(program, "uViewPos");
      } catch (e) { console.error(e); }
    }
    initShaderProgram();
    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;

    // Mouse and keyboard interactions
    let mouseDown = false, lastX, lastY, cubeRotX = (25*Math.PI/180), cubeRotY = 0; //
    let camX = 0, camY = -0.5, camZ = -9;

    canvas.addEventListener('mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('mousemove', e => {
      if (!mouseDown) return;
      let dx = e.clientX - lastX;
      let dy = e.clientY - lastY;
      cubeRotY += dx * 0.01;
      cubeRotX += dy * 0.01;
      lastX = e.clientX; lastY = e.clientY;
    });

    document.addEventListener('keydown', e => {
      const step = 0.2;
      switch (e.key) {
        case 'ArrowUp': camY -= step; break;
        case 'ArrowDown': camY += step; break;
        case 'ArrowLeft': camX += step; break;
        case 'ArrowRight': camX -= step; break;
        case 'w': camZ += step; break;
        case 's': camZ -= step; break;
      }
    });


    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
    let f = 1 / Math.tan(fov / 2);
    let proj = new Float32Array([
      f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zFar + zNear) / (zNear - zFar), -1, 0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    let startTime = Date.now();

    let geometries = [];
    function addGeometry(shape, texUrl, bumpUrl, material, bumpStrength){
      let buffs = initBuffers(shape);
      let texture = initTexture(texUrl);
      let bumpTexture = initTexture(bumpUrl);
      return{
        posbuff : buffs.posbuff,
        colbuff : buffs.colbuff,
        indbuff : buffs.indbuff,
        texbuff : buffs.texbuff,
        normbuff : buffs.normbuff,
        transformations : mat4Identity(),
        indicelen : shape.indices.length,
        texture : texture,
        bumpTexture : bumpTexture,
        material : material,
        bumpStrength : bumpStrength
      };
    }
    function makeMaterial(a,d,s,alph){
      return{
      ka: a,    // Ambient
      kd: d,    // Diffuse
      ks: s,    // Specular
      alpha: alph // Shininess
      };
    };
    
    
    geometries.push(addGeometry(donut, "textures/donuttext.png", "textures/donuttext.png", makeMaterial(0.2, 0.9, 0.2, 5), 8));
    geometries.push(addGeometry(frosting, "textures/frostingtex.png","textures/frostingtex.png", makeMaterial(0.2, 0.7, 0.4, 10), 3));
    geometries.push(addGeometry(sprinkleData, "textures/sprinkletex.png","textures/white.jpg", makeMaterial(0.2, 0.7, 0.5, 30), 0));
    geometries.push(addGeometry(table, "textures/marbletex.jpg","textures/white.jpg", makeMaterial(0.2, 0.4, 0.7, 70), 0));
    geometries.push(addGeometry(cup, "textures/whhite.jpg","textures/white.jpg", makeMaterial(0.2, 0.5, 0.95, 40), 0));
    geometries.push(addGeometry(coffee, "textures/coffeetex.png","textures/white.jpg", makeMaterial(0.2, 0.5, 0.7, 30), 0));
    geometries.push(addGeometry(plate, "textures/glasstex.png","textures/white.jpg", makeMaterial(0.2, 0.5, 0.95, 100), 0));
    geometries.push(addGeometry(wall, "textures/wall.png","textures/red_brick_disp_4k.png", makeMaterial(0.15, 0.6, 0.3, 1), 3));
    geometries.push(addGeometry(steam, "textures/Steam-018.webm","textures/white.jpg", makeMaterial(0.2, 0.5, 0.95, 40), 0));
    
    videoElement = document.createElement('video');
    videoElement.src = "textures/Steam-018.webm";
    videoElement.loop = true;
    videoElement.muted = true;
    videoElement.play();
    textureSource = videoElement;
    let vidtexture = gl.createTexture();

    let bounce = 0;
    function render() {
      if (videoElement && videoElement.readyState >=
        videoElement.HAVE_CURRENT_DATA) {
        gl.bindTexture(gl.TEXTURE_2D, vidtexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      }

      geometries[8].texture = vidtexture;
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // rotation matrices
      let cx = Math.cos(cubeRotY), sx = Math.sin(cubeRotY);
      let cy = Math.cos(cubeRotX), sy = Math.sin(cubeRotX);
      let rotX = [1, 0, 0, 0, 0, cy, sy, 0, 0, -sy, cy, 0, 0, 0, 0, 1];
      let rotY = [cx, 0, -sx, 0, 0, 1, 0, 0, sx, 0, cx, 0, 0, 0, 0, 1];
      let cubeRotation = multiplyMat4(rotY, rotX);

      // init model-view matrix as identity matrix
      let modelViewMatrix = mat4Identity();
      // init model transformation matrix as identity matrix
      let modelTransformationMatrix = mat4Identity();

      //delta time in ms
      let deltaTime = Date.now() - startTime;
      // object rotation
      modelTransformationMatrix = multiplyMat4(modelTransformationMatrix, cubeRotation);
      // camera translation
      modelViewMatrix = mat4Translate(modelViewMatrix, [camX, camY, camZ]);
      
      //set time in seconds
      gl.uniform1f(timeLoc, deltaTime/1000.0);
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);
      gl.uniformMatrix4fv(uMTM, false, modelTransformationMatrix);

      //set up lights
      gl.uniform3fv(uLightAPosLoc, [10,10,10]);
      gl.uniform3fv(uLightBPosLoc, [-10,10,-10]);
      gl.uniform3fv(uViewPosLoc, [0.0, 0.0, 0.0]);

      //=============transformations =======================
      let currentZ;
      if(bounce < 3){
        currentZ = Math.abs(2**(-deltaTime/500) * 5 * Math.cos(3 * (deltaTime/1000))) - 0.6;
      }
      else{
        currentZ = -0.6;
      }
      if(currentZ < -0.58){
        bounce +=1;
      }
      
      let donutMatrix = mat4Identity();
      donutMatrix = mat4RotateX(donutMatrix, -90 * Math.PI / 180); //rotate donut 90 deg
      donutMatrix = mat4Translate(donutMatrix, [-1.0, -1.0, currentZ]); //translate with the bounce
      donutMatrix = multiplyMat4(modelTransformationMatrix, donutMatrix);

      geometries[0].transformations = donutMatrix;
      geometries[2].transformations = donutMatrix;
      geometries[1].transformations = donutMatrix;

      let tableMatrix = mat4Identity();
      tableMatrix = mat4RotateX(tableMatrix, -90 * Math.PI / 180);
      tableMatrix = mat4Translate(tableMatrix, [0.5, -0.5, -1.255]);
      tableMatrix = multiplyMat4(modelTransformationMatrix, tableMatrix);

      geometries[3].transformations = tableMatrix;

      let cupMatrix = mat4Identity();
      cupMatrix = mat4RotateY(cupMatrix, -30 * Math.PI / 180);
      cupMatrix = mat4RotateX(cupMatrix, -90 * Math.PI / 180);
      cupMatrix = mat4Translate(cupMatrix, [1.25, 1.25, -1]);
      cupMatrix = multiplyMat4(modelTransformationMatrix, cupMatrix);

      geometries[4].transformations = cupMatrix;
      geometries[5].transformations = cupMatrix;

      let plateMatrix = mat4Identity();
      plateMatrix = mat4RotateX(plateMatrix, -90 * Math.PI / 180);
      plateMatrix = mat4Translate(plateMatrix, [-1, -1, -1]);
      plateMatrix = multiplyMat4(modelTransformationMatrix, plateMatrix);
      
      geometries[6].transformations = plateMatrix;

      let smokeMatrix = mat4Identity();
      smokeMatrix = mat4Translate(smokeMatrix, [1.675, 5, -0.5]);
      smokeMatrix = mat4RotateZ(smokeMatrix, Math.PI);
      smokeMatrix = multiplyMat4(modelTransformationMatrix, smokeMatrix);
      geometries[8].transformations = smokeMatrix;

      let wallMatrix = mat4Identity();
      wallMatrix = mat4Translate(wallMatrix, [0,0, -8]);
      wallMatrix = mat4RotateZ(wallMatrix, Math.PI);
      wallMatrix = multiplyMat4(modelTransformationMatrix, wallMatrix);
      geometries[7].transformations = wallMatrix;
      

      //==================draw each object====================================
      for (let i =0; i < geometries.length; i++){
        gl.uniform1f(uKaLoc, geometries[i].material.ka);
        gl.uniform1f(uKdLoc, geometries[i].material.kd);
        gl.uniform1f(uKsLoc, geometries[i].material.ks);
        gl.uniform1f(uAlphaLoc, geometries[i].material.alpha);
        gl.uniform1f(uBumpStrengthLoc, geometries[i].bumpStrength);

        gl.activeTexture(gl.TEXTURE0 + i); //unit is 0, 1, 2 ...
        gl.bindTexture(gl.TEXTURE_2D, geometries[i].texture);
        gl.uniform1i(uTexLoc,0 + i);

        gl.activeTexture(gl.TEXTURE1 + i);
        gl.bindTexture(gl.TEXTURE_2D, geometries[i].bumpTexture);
        gl.uniform1i(uBumpTexLoc, 1+i);

        gl.bindBuffer(gl.ARRAY_BUFFER, geometries[i].texbuff);
        gl.enableVertexAttribArray(texCoordLoc);
        gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, geometries[i].posbuff);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, geometries[i].colbuff);
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometries[i].indbuff);

        gl.bindBuffer(gl.ARRAY_BUFFER, geometries[i].normbuff);
        gl.enableVertexAttribArray(normalLoc);
        gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

        gl.uniformMatrix4fv(uMTM, false, geometries[i].transformations);
        gl.drawElements(gl.TRIANGLES, geometries[i].indicelen, gl.UNSIGNED_SHORT, 0);
      }
    }

    // Initialize when page loads
    window.onload = function () {
      setInterval(render, 30);
    }

  </script>
</body>

</html>
